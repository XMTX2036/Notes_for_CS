# CS106L

- Focus on **code**; what makes it good, what **powerful** and **elegant** code looks like
- Understand **how** and **why** C++ was made

## Intro

**What is C++?**

Basic Syntax + The STL

```C++

// =========================  C++ Way  ==============================

#include <iostream>

int hello_cpp() {
    std::cout << "Hello, world!" << std::endl;
    return 0;
}

// =========================  C Way  ==============================

#include "stdio.h"
#include "stdlib.h"

int hello_c() {
    printf("%s", "Hello, world!\n");
    return EXIT_SUCCESS;
}


// =========================  Assembly Way  ==============================

#include "stdio.h"
#include "stdlib.h"

/*
 * Wrapper function for convenience
 */
void myputs(char *s) {
    puts(s);
}

/*
 * This will probably not work on your computer.
 * Assembly is not at all portable; a good
 * reason to avoid using it!
 *
 * Those of you who have taken 107 should
 * be able to somewhat see what is happening here.
 */
int hello_as() {
    /* The assembly literally writes the hex representation
     * of as big a portion of the string as it can into the addresses
     * at range rsp to rsp + 0xd. That range is exactly 12 bytes long
     * as there are 12 characters in the "Hello, wordl!" string.
     */
    asm("sub    $0x20,%rsp\n\t"
        "movabs $0x77202c6f6c6c6548,%rax\n\t"   // moves "Hello, w" portion to mem at $rsp
        "mov    %rax,(%rsp)\n\t"
        "movl   $0x646c726f, 0x8(%rsp)\n\t"     // moves "orld"  portion to mem at $rsp + 8
        "movw   $0x21, 0xc(%rsp)\n\t"           // moves "!" portion to mem at $rsp + 12
        "movb   $0x0,0xd(%rsp)\n\t"             // moves string null terminator to mem at $rsp + 13
        "leaq    (%rsp),%rax\n\t"               // loads address of $rsp as first argument to puts
        "mov    %rax,%rdi\n\t"
        "call  __Z6myputsPc\n\t"                // calls puts
        "add    $0x20, %rsp\n\t"
    );
    return EXIT_SUCCESS;
}


int main() {
    hello_cpp();
    hello_c();
    hello_as();
}
```



## Lec1 Types and Structs

### **C++ Fundamental Types++**

int, char, float, double, bool, **string**

### **C++ is a statically typed language**

- **statically typed**:everything with a name (variables, functions, etc) is given a type before runtime

- Python is a dynamic typed language
- static typing helps us to prevent errors before our code runs

### **Overloading**

### Intro to structs

**std::pair**:An STL built-in struct with two fields of any type

- a `template`: specify the types of the fields insides <>

- first & second

- Use `std::pair` to return **success+result**

  ```C++
  std::pair<bool, Student> lookupStudent(string name) {
    Student blank;
  	if (notFound(name)) return std::make_pair(false, blank);
   	Student result = getStudentWithName(name);
  	return std::make_pair(true, result);
  }
  std::pair<bool, Student> output = lookupStudent(“Keith”);
  ```

- To avoid specifying the types of a pair, use `std::make_pair(field1, field2)`

### Aside: Type Deduction with auto

`auto` does not mean that the variable doesn’t have a type. It means that **the type is deduced by the compiler.** 

### Code

a function to get the root of $ax^2+bx+c=0$

```C++
std::pair< bool, pair<double, double> > quadratic(double a, double b, double c)
{
	//get radical, test if negative, return indicating no roots
	double radical = b*b - 4*a*c;
	if(radical < 0) return {false, {-1, -1}}
	//otherwise get roots and return
	double root1 = ( -1*b + sqrt(radical) ) / (2*a);
	double root2 = ( -1*b - sqrt(radical) ) / (2*a);
	
	return {true, {root1, root2}};
}
```



## Lec2 Streams

### Input streams

`std::cin` has type `std::istream`

Input file streams `std::ifstream`

`std::getline(istream& stream, string& line);`

**Don't mix >> with getline**

### Output streams

`std::cout` has type `std::ostream`

Output file streams `std::ofstream`

### File streams and string streams

Stringstreams

### Code

```C++
void readHaikuWord() {
    // Create our ifstream and make it open the file
    std::ifstream input("res/haiku.txt");

    // This will store the values as we get them form the stream
    string word;
    while(true) {
        // Extract next word from input
        input >> word;

        // If input is in a fail state, either a value couldn't
        // be converted, or we are at the end of the file.

        if(input.fail())
            break;

        cout << "Word read: " << word << endl;
    }
}
```

```C++
int StringToInteger(const string& str) {
    /*
     * We'll specifically use an istringstream, which is just a
     * stringstream that you can only get things from.
     *
     * You can set its internal string when creating it or by doing
     * converter.str("string_to_set");
     */
    std::istringstream converter(str);
    /*
     * Try getting an int from the stream. If this is not succesful
     * then user input was not a valid input.
     */
    int value;
    if(converter >> value) {
        /*
         * See if we can extract a char from the stream.
         * If so, the user had junk after a valid int in their input.
         */
        char rem;
        if(converter >> rem) {
            /*
             * Throwing an error is a way of propogating up the funcion
             * callstack that something went wrong. Previous functions can
             * anticipate such an error and catch it. In this case, we will
             * just let the thrown domain_error propogate up until it terminates
             * the program.
             *
             * A domain_error is defined in the standard namespace as an error
             * to signal that the input arguments to the function were not valid.
             */
            throw std::domain_error(string("Unexpected character in input: ") + rem);
        }
        return value;
    }
    /* throw a domain error with a helpful error message. */
    throw std::domain_error(string("Failed to convert input: ") + str);
}
```

**Notes:**

- There is function `fail()` to judge whether the file reading is successful
- the good code should deal with the potential error well.(The second code phase use std::domain_error to deal with the input error)



## Lec3 Initilization & References

### Initilization

```C++
// struct init
/** way 1 **/
Student s;
s.name = "Frankie";
s.state = "MN";
s.age = 21;
/** way 2 **/
Student s = {"Frankie", "MN", 21};

// std::pair init
/** way 1 **/
std::pair<int, string> numSuffix1 = {1,"st"};
/** way 2 **/
std::pair<int, string> numSuffix2;
numSuffix2.first = 2;
numSuffix2.second = "nd";
/** way 3 **/
std::pair<int, string> numSuffix2 = std::make_pair(3, "rd");

// vector init
std::vector<int> vec1(3,5);
// makes {5, 5, 5}, not {3, 5}!
std::vector<int> vec2;
vec2 = {3,5};
// initialize vec2 to {3, 5} after its declared 
```

**Uniform initilization**

Curly bracket initialization. Available for all types, immediate initialization on declaration!

```C++
std::vector<int> vec{1,3,5};
std::pair<int, string> numSuffix1{1,"st"};
Student s{"Frankie", "MN", 21};
// less common/nice for primitive types, but possible!
int x{5};
string f{"Frankie"};
```

**TLDR**: use uniform initialization to initialize every field of your non-primitive typed variables - but be careful not to use vec(n, k)!

**Structured Binding**

```C++
std::pair< bool, pair<double, double> > quadratic(double a, double b, double c)
{
	//get radical, test if negative, return indicating no roots
	double radical = b*b - 4*a*c;
	if(radical < 0) return {false, {-1, -1}}
	//otherwise get roots and return
	double root1 = ( -1*b + sqrt(radical) ) / (2*a);
	double root2 = ( -1*b - sqrt(radical) ) / (2*a);
	
	return {true, {root1, root2}};
}
/*
int main() {
  auto a, b, c;
 	std::cin >> a >> b >> c;
 	auto result = quadratic(a, b, c);
 	auto found = result.first;
 	if (found) {
 		auto solutions = result.second;
 		std::cout << solutions.first << solutions.second << endl;
 	} else {
 		std::cout << “No solutions found!” << endl;
 	}
}
*/
// A better way to write the main()
int main() {
   auto a, b, c;
   std::cin >> a >> b >> c;
   auto [found, solutions] = quadratic(a, b, c);
   if (found) {
   	auto [x1, x2] = solutions;
   	std::cout << x1 << “ ” << x2 << endl;
   } else {
   	std::cout << “No solutions found!” << endl;
   }
}
```

**Structured binding lets you initialize directly from the contents of a struct**

### References

```C++
void shift(vector<std::pair<int, int>>& nums) {
  // must write the reference&
  for (auto& [num1, num2]: nums) {
    num1++;
    num2++;
  }
}
```

**l-values & r-values**

- l-values have names
- l-values are not temporary

**C++, by default, makes copies when we do variable assignment! We need to use & if we need references instead**

## Lec4 Containers

### Standard Template Library(STL)

- Containers
- Iterators
- Functions
- Algorithms

### Containers

- Sequence Containers

  - Simple

    `vector` `deque` `list` `tuple`

  - Adaptors

    `stack` `queue` `priority_queue`

- Associative Containers

  - Ordered

    `set` `map`

  - Unordered

    `unordered_set` `unordered_map`

![截屏2022-08-19 15.44.26](https://xmtxpic.oss-cn-hangzhou.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2022-08-19%2015.44.26.png)

**Summary of Sequence Containers**

- `std::vector` use for almost everything
- `std::deque` use if you are frequently inserting/removing at front
- `std::list` use very rarely, and only if you need to split/join multiple lists

**Container Adaptors** ——wrappers in C++

`std::stack` and `std::queue` are both written by `std::deque`

**STL maps actually store pairs**

Every `std::map` is actually backed by: `std::pair`

**Both STL maps and sets require comparison operator**

By default, the type (for sets) or key’s type (for maps) must have a comparison operator (<) defined.

```C++
// Map 
// if k doesn't exist, then create the key-value pair(k, )
map[k];
// if k doesn't exist, then throw an exception
map.at(k); 
```

