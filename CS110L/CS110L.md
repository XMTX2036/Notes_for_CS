# CS110L

## Lecture 1 

## Lecture 2	Memory Safety in Rust

### Dangling Pointers

```C++
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}                   // 变量a和c的作用域结束
```

a与c都是局部变量，在离开作用域后，`a` 所申请的栈上内存都会被系统回收，从而造成了 `悬空指针(Dangling Pointer)` 的问题

### Double Free

```C++
void main() {
   Vec* vec = vec_new();
   vec_push(vec, 107);
   int* n = &vec->data[0];
   vec_push(vec, 110);
   printf("%d\n", *n);
   free(vec->data);
   vec_free(vec); // YIKES
}
```

### Iterator Invalidation(迭代器失效)

```C++
void main() {
   Vec* vec = vec_new();
   vec_push(vec, 107);
   int* n = &vec->data[0];
   vec_push(vec, 110);
   printf("%d\n", *n); // :(
   free(vec->data);
   vec_free(vec);
}
```

### Memory Leak

```C++
void vec_push(Vec* vec, int n) {
   if (vec->length == vec->capacity) {
   int new_capacity = vec->capacity * 2;
   int* new_data = (int*) malloc(new_capacity);
   assert(new_data != NULL);
   for (int i = 0; i < vec->length; ++i) {
   new_data[i] = vec->data[i];
   }
   vec->data = new_data; // OOP: we forget to free the old data
   vec->capacity = new_capacity;
   }
   vec->data[vec->length] = n;
   ++vec->length;
}
```

### 堆(Heap)与栈(Stack)

栈：局部变量

堆：malloc() & free()

### Ownership

- Each value in Rust has a variable that's called its owner.
- There can only be 1 onwer at a time.

- When the owner goes out of scope, the value will be dropped.

对于Rust的基本类型，存储在栈上；而String等非Rust基本类型变量是存储在堆上的

**Self- learning**

如何在不需要时释放内存空间

- 垃圾回收机制(GC)——Java，Go
- 手动管理内存的分配和释放——C++
- 通过所有权来管理内存——Rust

通过所有权(Ownership)来管理内存，检查*只发生在编译期*

Ownership in Functions



### Borrowing

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

使用&表示借用，通过*用来解引用

**不可变引用**

```rust
change(&s);
```

**可变引用**

```rust
change(&mut s);
```

总结：

- 同一时刻，只能有一个可变引用/多个不可变引用
- 引用必须总是有效的

- The ownership and borrowing rules are enforced at compile time!

## Lecture3	Ownership(Cont.) and Error Handling

### Compile Time & Run Time

- Passing ownership: just passes a pointer
  - The compiler will insert the appropriate free() call
- Passing references: just passes a pointer
- Explicit copy: copies memory

### Handling NULLs

### Exceptional Exceptions

